/**
 * generated by Xtext 2.34.0
 */
package org.xtext.generator;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Hashtable;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.xtext.mCC.Application;
import org.xtext.mCC.Fragment;
import org.xtext.mCC.Structure;
import org.xtext.mCC.Model
import java.util.ArrayList
import org.xtext.mCC.Mobile
import org.xtext.mCC.Cloud

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MCCGenerator extends AbstractGenerator {
	var int id=0;
	var list =new ArrayList<String[]>
	var registry=new Hashtable<String, Integer>();

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
id=0
				for(m:resource.allContents.toIterable.filter(typeof(Model))){
					for(s:m.systems){
						fsa.generateFile(s.name+".xml", s.devices.get(0).applications.get(0).compile(resource))
					}
				}
	}
	
//start
  
  def compile(Application a, Resource r){
		var i=0;
		for(fragment:a.fragments){
			registry.put(fragment.name, i)
			i=i+1
		}
		
		staticPart
		
	
		'''<?xml version="1.0" encoding="utf-8"?><!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'>
		<nta>
		<declaration>«a.GlobalDeclarations(r)»</declaration>
		«FOR fragment:a.fragments»
		«fragment.compile(a.structure)»
		«ENDFOR»
	
		
«««		«Manager»
«««		«Local»
«««		«Remote»
«««		«LocalCpu»
«««		«remoteCpu»
		«staticPart.toString»
      
		
		<system>system «FOR f:a.fragments»«f.name»,«ENDFOR»Manager, Local, Remote, LocalCPU, RemoteCPU, CLOCK;</system>
		</nta>'''
	}
	
	def StringBuilder getStaticPart() {
		var br =new BufferedReader(new InputStreamReader(getClass().getResourceAsStream("conf.xml"))); 

			var sCurrentLine="";
			var sb=new StringBuilder(); 

			while ((sCurrentLine = br.readLine()) != null) {
				sb.append(sCurrentLine);
				sb.append("\n")
			}
		return sb;

	}
	
	
	
	
	
	

	def compile(Fragment f, Structure s){ 
		
		'''
		<template>
		<name x="5" y="5"> «f.name» </name>
		<declaration></declaration>
		«var edges=s.edges.filter[start.name==f.name]»
		«var leafFragment=false»
		«var middle=""»
		«IF edges.length==0»
		«leafFragment=true»
		«ELSE»
		«middle="id"+ID»
		«createLocation(middle, null)»
		«ENDIF»
		
		«val startLocation="id"+ID»
		
		«createLocation(startLocation, null)»
		«FOR e:edges»
		«IF e.operator.toString=="-->"»
		«FOR destinationFragment:e.stop»
		«val x=list.add(#[middle.toString, startLocation.toString, null, null, "F["+registry.get(destinationFragment.name)+"]!",null])»
		«ENDFOR»
		«ENDIF»
		
		
		«IF e.operator.toString=="--|"»
		«val x=list.add(#[middle.toString, startLocation.toString, null, null, "B["+registry.get(f.name)+"]!",null])»
		«ENDIF»
		
		«IF e.operator.toString=="--::"»
		«val destinationFragments=e.stop.reverseView»
		«««frags=7,6,5 già girato
		«FOR i:0..destinationFragments.length-1»
		«IF i==0»
		«««		7
		«sequentialPart(registry.get(destinationFragments.get(i).name).toString, registry.get(f.name).toString, lastID, true, startLocation, middle)»
		«ELSEIF i==destinationFragments.size-1»
		«««		5
		«val x=list.add(#[middle.toString,lastID, null, null, "F["+registry.get(destinationFragments.get(i).name).toString+"]!", null])»
		«ELSE»
		«««		6
		«sequentialPart(registry.get(destinationFragments.get(i).name).toString, registry.get(f.name).toString, lastID, false, startLocation, middle)»
		
		«ENDIF»
		
		
		«ENDFOR»
		«ENDIF»
		«ENDFOR»
		
		«commonPart(startLocation, middle, registry.get(f.name).toString, s, f, leafFragment, startLocation)»
		
		«FOR t:list»
		«createTransition(t.get(0),t.get(1), t.get(2), t.get(3), t.get(4), t.get(5))»
		«ENDFOR»
		«list.clear»
		</template>
		
		'''
	}
	
	def String sequentialPart(String destinationID, String fragmentID, String lastIDLoc, Boolean lastLocation, String startLocation, String middle){

		val String newLocation="id"+ID
		if(lastLocation){
			list.add(#[newLocation, startLocation, null, null, "F["+destinationID+"]!", null])
		}else{
			list.add(#[newLocation, lastIDLoc, null, null, "F["+destinationID+"]!", null])
		}

		
		val String managerLocation="id"+ID
		list.add(#[managerLocation, newLocation, null, null, "completed["+fragmentID+"]?", null])
		list.add(#[managerLocation, managerLocation, null, null, "manager["+fragmentID+"]!", null])
		val String initLocation="id"+ID
		list.add(#[initLocation, managerLocation, null, null, "F["+fragmentID+"]?", "setInstructions("+ fragmentID+")"])
		'''
		«createLocation(newLocation, null)»
		«createLocation(managerLocation, null)»
		«createLocation(initLocation, null)»
		'''
	}
	
	def commonPart(String initLocation, String terminalID, String fragmentID, Structure s, Fragment f, Boolean leafFragment, String startLocation){
		val String newLocation="id"+ID
		if(leafFragment){
			list.add(#[newLocation, startLocation, null, null, "completed["+fragmentID+"]?", null])
		}else{
			list.add(#[newLocation, terminalID, null, null, "completed["+fragmentID+"]?", null])
		}
	
		list.add(#[newLocation, newLocation, null, null, "manager["+fragmentID+"]!", null])


		var String initLocationSpecial=null;
		if(f.init=='init'){
			initLocationSpecial="id"+ID
			list.add(#[initLocationSpecial, newLocation, null, null, null, "setInstructions("+ fragmentID+")"])
		}else{
			list.add(#[initLocation, newLocation, null, null, "F["+fragmentID+"]?", "setInstructions("+ fragmentID+")"])
		}
		
		for(e:s.edges.filter[operator.toString=="--|"]){	
		if(e.stop.contains(f)){
			list.add(#[initLocation, newLocation, null, null, "B["+registry.get(e.start.name)+"]?","setInstructions("+ fragmentID+")"])
		}
		}
		
		'''
		«createLocation(newLocation, null)»
		«IF initLocationSpecial!=null»
		«createLocation(initLocationSpecial, null)»
		<init ref="«initLocationSpecial»"/>
		«ELSE»
		<init ref="«initLocation»"/>
		«ENDIF»
«««		«createLocation(initLocation, null)»
		
		'''
	}
	
		
	def int getID(){
		return id=id+1
	}
	def getLastID(){
		return "id"+id
	}
	
	def createLocation(String i, String type){
		'''
	<location id="«i»">
		<name>«i»</name>
		«IF type!=null»
		<«type»/>
		«ENDIF»
	</location>'''
	}
	
	def createTransition(String s, String t, String select, String guard, String sync, String ass){
		'''
		<transition>
			<source ref="«s»"/>
			<target ref="«t»"/>
			«IF select!=null»	<label kind="select" >«select»</label>«ENDIF»
			«IF guard!=null»	<label kind="guard" >«guard»</label>«ENDIF»
			«IF sync!=null»	<label kind="synchronisation" >«sync»</label>«ENDIF»
			«IF ass!=null»	<label kind="assignment" >«ass»</label>«ENDIF»
		</transition>
		'''

		
	}
	
	
	def Manager(){
		'''<template><name>Manager</name>
		<declaration>int x;
		/*
		0=null
		1=loadL
		2=loadR
		3=offload
		4=migrate
		5=back
		6=restore
		7=disposeL
		8=disposeR
		*/
void localRemoteSync(int i){
if(IsLocal==true){
clockTime=(Info[i].megaByte*10)/network;
if(battery>(clockTime/10)){
battery-=(clockTime/10);
}else{
battery=0;
}

}
}

void remoteLocalSync(int i){
if(IsLocal==false){
clockTime=(Info[i].megaByte*10)/network;
if(battery>(clockTime/10)){
battery-=(clockTime/10);
}else{
battery=0;
}
}
}
</declaration>
«val init="id"+ID»
«val second="id"+ID»
«createLocation(init, "committed")»
«createLocation(second, null)»
<init ref="«second»"/>

«createTransition(init, second, null, "operation[x]!=0 and operation[x]==5","disposeR[x]!","operation[x]=8")»
«createTransition(init,second,null,"operation[x]!=0 and operation[x]==3","disposeL[x]!","operation[x]=7")»
«createTransition(init, second,null,"operation[x]==0","loadL[x]!","operation[x]=1")»
«createTransition(init,second,null,"operation[x]==0 and Info[x].isOffloadable==true","loadR[x]!","operation[x]=2")»
«createTransition(init,second,null,"operation[x]!=0 and (operation[x]==2 or operation[x]==3 or operation[x]==4 or operation[x]==7)","restore[x]!","operation[x]=6")»
«createTransition(init,second,null,"operation[x]!=0 and (operation[x]==2 or operation[x]==3 or operation[x]==4 or operation[x]==7)","back[x]!","operation[x]=5")»
«createTransition(init,second,null,"Info[x].isOffloadable==true and operation[x]!=0 and (operation[x]==1 or operation[x]==5 or operation[x]==6 or operation[x]==8)","migrate[x]!","operation[x]=4")»
«createTransition(init,second,null,"Info[x].isOffloadable==true and operation[x]!=0 and (operation[x]==1 or operation[x]==5 or operation[x]==6 or operation[x]==8)","offload[x]!","operation[x]=3")»
«createTransition(second,init,"e : id_t","(fragmentToCompute!=e or instructionsNumber[e]>0)and p==true and battery>20","manager[e]?","x=e")»
	</template>
	'''
}



def Local(){
	'''
	<template>
	<name>Local</name>
	<parameter>const id_t i</parameter>
	<declaration>
	</declaration>
	«val idle="id"+ID»
	«val nul="id"+ID»
	«val running="id"+ID»
	«createLocation(idle, null)»
	«createLocation(nul, null)»
	«createLocation(running, null)»
	<init ref="«nul»"/>
	
	«createTransition(idle, running,null,null,"loadL[i]?","setInstructions(i), initDataSync(i)")»
	«createTransition(running, running ,null,"instructionsNumber[i]>0","executeL!","fragmentToCompute=i, p=true, isLocal[i]=true")»
	«createTransition(nul, running,null,null,"loadL[i]?","memoryUp(i), setInstructions(i), initDataSync(i)")»
	«createTransition(idle, nul,null,null,"disposeL[i]?","memoryDown(i)")»
	«createTransition(running, nul,null,null,"migrate[i]?","memoryDown(i), dataSync(i)")»
	«createTransition(running, idle,null,null,"offload[i]?","dataSync(i)")»
	«createTransition(running, idle,null,"instructionsNumber[i]==0","completed[i]!","isLocal[i]=true, where=true")»
	«createTransition(idle, running,null,null,"restore[i]?","memoryUp(i)")»
	«createTransition(idle, running,null,null,"back[i]?","memoryUp(i)")»
	«createTransition(nul, running,null,null,"restore[i]?","memoryUp(i)")»
	«createTransition(nul, running,null,null,"back[i]?","memoryUp(i)")»
	</template>
	'''
}

def Remote(){
	'''
	<template>
	<name>Remote</name>
	<parameter>const id_t i</parameter>
	<declaration>void initDataSync(int i){
	if(isLocal[i]==true){
	int var=(Info[i].megaByte*10)/network;
	globalTime+=var;
	battery-=(var/10);
	}
	}
	
	void dataSync(int i){
	if(isLocal[i]==false){
	int var=(Info[i].megaByte*10)/network;
	globalTime+=var;
	battery-=(var/10);
	}
	}</declaration>
	«val idle="id"+ID»
	«val nul="id"+ID»
	«val running="id"+ID»
	«createLocation(idle, null)»
	«createLocation(nul, null)»
	«createLocation(running, null)»
	<init ref="«nul»"/>
	
	«createTransition(idle, running,null,null,"loadR[i]?","setInstructions(i), initDataSync(i)")»
	«createTransition(running, running,null,"instructionsNumber[i]>0","executeR!","fragmentToCompute=i, p=true, isLocal[i]=false")»
	«createTransition(nul, running,null,null,"loadR[i]?","setInstructions(i), initDataSync(i)")»
	«createTransition(idle, nul,null,null,"disposeR[i]?",null)»
	«createTransition(running, nul,null,null,"restore[i]?","dataSync(i)")»
	«createTransition(running, idle,null,null,"back[i]?","dataSync(i)")»
	«createTransition(running, idle,null,"instructionsNumber[i]==0","completed[i]!","isLocal[i]=false, where=false")»
	«createTransition(idle, running,null,null,"migrate[i]?",null)»
	«createTransition(idle, running,null,null,"offload[i]?",null)»
	«createTransition(nul, running,null,null,"migrate[i]?",null)»
	«createTransition(nul, running,null,null,"offload[i]?",null)»
	</template>
	
	'''
}

def LocalCpu(){
	'''
	<template>
	<name>LocalCPU</name>
	<declaration>void compute(){if(instructionsNumber[fragmentToCompute]>=mobileInstructions){	battery-=10;	instructionsNumber[fragmentToCompute]-=mobileInstructions;}else{battery-=((instructionsNumber[fragmentToCompute]*10)/mobileInstructions);	instructionsNumber[fragmentToCompute]=0;}globalTime+=10;}</declaration>
	«val init="id"+ID»
	«val second="id"+ID»
	«createLocation(init, "committed")»
	«createLocation(second, null)»
	<init ref="«second»"/>
	
	«createTransition(init, second, null, null, null, "compute()")»
	«createTransition(second, init, null, null, "executeL?", null)»
	</template>
	'''
}
	
	def remoteCpu(){
	'''
	<template>
	<name>RemoteCPU</name>
	<declaration>void computeR(){if(instructionsNumber[fragmentToCompute]>=cloudInstructions){	instructionsNumber[fragmentToCompute]-=cloudInstructions;}else{	instructionsNumber[fragmentToCompute]=0;}globalTime+=10;}</declaration>
	«val init="id"+ID»
	«val second="id"+ID»
	«createLocation(init, "committed")»
	«createLocation(second, null)»
	<init ref="«second»"/>
	
	«createTransition(init, second, null, null, null, "computeR()")»
	«createTransition(second, init, null, null, "executeR?", null)»
	</template>
	'''
}
	
	
def GlobalDeclarations(Application a, Resource r) {
		val mobile=r.allContents.toIterable.filter(typeof(Mobile)).last
		val cloud=r.allContents.toIterable.filter(typeof(Cloud)).last
		'''
		
const int N=«a.fragments.size»;
typedef int[0, N-1] id_t;

const int mobileInstructions=«mobile.cpuInstructions», cloudInstructions=«cloud.cpuInstructions»;

bool IsLocal=true;
bool managerEnabled=true;
int[0,2] fragmentStateLocal[N], fragmentStateRemote[N]; //0=null, 1=idle, 2=running


const int[0,100]  network=«mobile.network»;
int[0,100] battery=«mobile.battery»;
clock globalTime;

int clockTime;
int memory ;

int energy ;


chan F[N], startL[N], startR[N], stopL[N], stopR[N], disposeL[N], disposeR[N], completed[N], manager[N], time, timeR;
broadcast chan B[N];
chan executeL, executeR;

//istruzione spedite al processore
int[0,N] fragmentToCompute=N;
int[0,150] instructionsNumber[N];



typedef struct 
{ int[0,150] instructions;  
int[0,200] memory;
int[0,100] megaByte;
bool isOffloadable;
} Fragment;
const Fragment Info[N]={
	«FOR f:a.fragments»
	{«f.instructions»,«f.memory»,«f.sync», «f.isOfflodable»}
	«IF f.name!=a.fragments.last.name»
	,
	«ENDIF»
	«ENDFOR»
	
};




void memoryUp(int f){
memory+=Info[f].memory;
}


void memoryDown(int f){
memory-=Info[f].memory;
}


void setInstructions(int i){
instructionsNumber[i]=Info[i].instructions;
}


'''
		

	}	
  
//end
}


